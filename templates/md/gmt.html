<style>.bg-blue-200{--bg-opacity:1;background-color:#bee3f8;background-color:rgba(190,227,248,var(--bg-opacity))}.bg-green-200{--bg-opacity:1;background-color:#c6f6d5;background-color:rgba(198,246,213,var(--bg-opacity))}.bg-orange-200{--bg-opacity:1;background-color:#feebc8;background-color:rgba(254,235,200,var(--bg-opacity))}.mx-auto{margin-left:auto;margin-right:auto}.h-full{height:100%}.animate-pulse{animation:pulse 2s cubic-bezier(.4,0,.6,1) infinite}@keyframes pulse{50%{opacity:.5}}.bg-yellow-200{--bg-opacity:1;background-color:#fefcbf;background-color:rgba(254,252,191,var(--bg-opacity))}.bg-teal-300{--bg-opacity:1;background-color:#81e6d9;background-color:rgba(129,230,217,var(--bg-opacity))}.list-disc{list-style-type:disc}.list-inside{list-style-position:inside}.bg-red-200{--bg-opacity:1;background-color:#fed7d7;background-color:rgba(254,215,215,var(--bg-opacity))}.transition-opacity{transition-property:opacity}.duration-500{transition-duration:.5s}.ease-in-out{transition-timing-function:cubic-bezier(.4,0,.2,1)}.opacity-0{opacity:0}.bg-purple-200{--bg-opacity:1;background-color:#e9d8fd;background-color:rgba(233,216,253,var(--bg-opacity))}.text-blue-700{--text-opacity:1;color:#2b6cb0;color:rgba(43,108,176,var(--text-opacity))}</style>
<h1 id="introduction">Introduction</h1>
{% func GmtIntroduction() %}
<p><em>&quot;Hey, I am developing a web app.&quot;</em></p>
<br>
<p><em>&quot;Cool! What are you using for your frontend? <a href="https://react.dev/"  class="btn bg-blue-200" ><strong>React</strong></a>
? <a href="https://vuejs.org/"  class="btn bg-green-200" ><strong>Vue</strong></a>
? <a href="https://svelte.dev/"  class="btn bg-orange-200" ><strong>Svelte</strong></a>?&quot;</em></p>
<br>
<div x-data="{show:false}"><div>
<p><strong><div  class="btn btn-primary" x-show="!show" @click="show=true" >The obvious answer</div><strong>
<strong><img src="./assets/gmt/gigachad.jpg" alt="Gigachad"  class="mx-auto h-full" x-show="show"></strong></p>
{% endfunc %}
<h1 id="why">Why?</h1>
{% func GmtWhy() %}
<p><em><a href="https://en.wikipedia.org/wiki/Markdown"  class="btn bg-blue-200" target="_blank" ><strong>Markdown</strong></a></em> is a markup language to write formatted text.
<br></p>
<br>
<p>Writing Markdown files (<strong><code>.md</code></strong> extensions) using a text editor that has some plugins for it feels good compared to the other options: Markdown is not as plain as a <code>.txt</code> file, it is not slow at loading like MS Word, and best thing of all, the files can be converted into <strong><code>.html</code></strong>: they can be displayed in the browser and if the links are provided inside the contents then it becomes easy to navigate back and forth between them.</p>
<br>
<p>It allows for some shorthand syntax like</p>
<pre><code class="language-md">**bold**, _italic_, ~~strikethrough~~
</code></pre>
<br>
<p>which, after using a Markdown processor are then transformed into html elements</p>
<pre><code class="language-md">&lt;strong&gt;bold&lt;/strong&gt;, &lt;em&gt;italic&lt;/em&gt;, &lt;del&gt;strikethrough&lt;/del&gt;
</code></pre>
<br>
<p>and will look like <strong>bold</strong>, <em>italic</em>, <del>strikethrough</del> on the browser.</p>
<br>
<h2 id="markdown-instead-of-html">Markdown instead of HTML</h2>
<p>It is true that Markdown can be converted to HTML but the conversion just parse the contents into the corresponding HTML tags.</p>
<br>
<p>The interactions (JavaScript) and the styling (CSS) are both missing in the final converted <strong><code>.hml</code></strong> file.</p>
<br>
<p>Then I remembered how HTMX, Tailwind CSS and Alpine JS work: the interactions and the styling can be implemented by adding attributes to the HTML element.</p>
<br>
<p>But the problem is that in order to add attributes from Markdown you have to encapsulate the content inside an HTML element (yes, in Markdown you can use plain HTML) and add what you need in that element.</p>
<p>Another option is to use some <a href="https://boringrails.com/tips/jekyll-css-class"  target="_blank" class="bg-orange-200 animate-pulse" ><strong>specific Markdown processors</strong></a> that have
a <a href="https://kramdown.gettalong.org/syntax.html#block-ials"  target="_blank" class="bg-yellow-200 animate-pulse" ><strong>set of rules</strong></a> to accomplish the task.</p>
<br>
<p><strong>I didn't like the syntax so I decided to try and build a tool for it.</strong></p>
{% endfunc %}
<h1 id="parser">Parser</h1>
{% func GmtParser() %}
<p>The first step is to have a basic Markdown processor with functionalities that can be extended.</p>
<br>
<p>I started reading the book <a href="https://interpreterbook.com/"  class="bg-teal-300 animate-pulse" target="_blank" ><strong>Writing An Interpreter In Go</strong></a> that explains the steps to build a programming language interpreter from scratch:</p>
<br>
<ul  class="list-disc list-inside" >
<li>Define the <strong>tokens</strong> and the <strong>keywords</strong> to look for inside the contents</li>
<li>Build a lexer that reads and tokenize the contents</li>
<li>Parse the tokens and build an <strong>Abstract Syntax Tree</strong> (AST) of nodes from the sequence of tokens and the syntax of the content's programming language</li>
<li>Render the elements of the tree into the new programming language</li>
</ul>
<br>
<p>I tried to apply these concepts to parse Markdown into HTML.</p>
<br>
<p><em><strong  class="btn btn-primary" hx-get="gmt/result" hx-swap="outerHTML" >The Result</strong></em></p>
{% endfunc %}
{% func GmtResult() %}
<p>After a weekend I <strong  class="bg-green-200" >successully</strong>
... <strong  class="bg-red-200 transition-opacity duration-500 ease-in-out opacity-0" hx-ext="class-tools" classes="remove opacity-0:2s" >gave up</strong></p>
{% endfunc %}
<h1 id="reason">Reason</h1>
{% func GmtReason() %}
<p>The reason is that there are too many rules to be implemented in the parsing step.  <a href="https://github.github.com/gfm/"  target="_blank" class="bg-purple-200 animate-pulse" ><strong>GitHub Flavored Markdown Spec</strong></a> has a huge list of them.</p>
<br>
<p>Most importantly, there are already some high quality Markdown parser projects out there.</p>
<br>
<p>The one I chose to use is <a href="https://github.com/yuin/goldmark/"  target="_blank" class="bg-orange-200 animate-pulse" ><strong>goldmark</strong></a>, written in Go. It has many parameters that can be set and many extensions already available.</p>
<br>
<p>My favorite feature is that it supports <a href="https://pikchr.org/home/doc/trunk/homepage.md"  target="_blank" class="bg-green-200 animate-pulse" ><strong>Pikchr</strong></a>, a tool to sketch diagrams like the one on the first page of the website.</p>
<br>
<p>I tried <a href="https://mermaid.js.org/intro/"  target="_blank" class="bg-red-200 animate-pulse" ><strong>Mermaid JS</strong></a> in the past to draw the diagrams.</p>
<p>It has a nice syntax but it executes some JavaScript in order to render the contents.</p>
<p>I remember using Mermaid's <a href="https://mermaid.js.org/syntax/entityRelationshipDiagram.html"><strong>Entity Relationship Diagram</strong></a> to write a Markdown file with all the tables and columns of a database: the converted HTML file opened on the browser was taking too much time to render the contents.</p>
<br>
<p><strong>Pikchr</strong> on the other hand needs an intermediate parsing step: the final result is an <strong><code>svg</code></strong> element, so the diagram is already ready to be displayed once it is opened in the browser.</p>
<br>
<br>
<br>
<p>Going back to the Markdown parsing tool... what is needed now is to find a mechanism to insert attributes from Markdown to the final converted HTML</p>
{% endfunc %}
<h1 id="implementation">Implementation</h1>
{% func GmtImplementation() %}
<p>In the end I opted to make it so that the commented contents get <em>injected</em> to the next element using some regexes (this step happens after the first HTML is parsed by <strong>goldmark</strong>'s tool).</p>
<br>
<p>The repo: <a href="https://github.com/Jiang-Gianni/gmt"  target="_blank" class="bg-teal-300 animate-pulse" ><strong>Github</strong></a></p>
<br>
<p>I also added some Tailwind CSS: I extracted the utility classes definition into the codebase.</p>
<p>The Tailwind styling definition is added in a <strong><code>style</code></strong> tag on top of the converted HTML in case they appear as classes.</p>
<br>
<p>I have not tested many Tailwind classes (and probably most of them won't work correctly yet), but the ones I needed to use (basic stuff like bg-color, text-color etc) seem to work fine.</p>
<br>
<h2 id="example">Example</h2>
<pre><code class="language-md">&lt;!-- class=&quot;text-blue-700&quot; --&gt;
# My blue title
</code></pre>
<br>
<p>is parsed as:</p>
<br>
<pre><code class="language-html">&lt;style&gt;.text-blue-700{--text-opacity:1;color:#2b6cb0;color:rgba(43,108,176,var(--text-opacity))}&lt;/style&gt;
&lt;h1 id=&quot;my-blue-title&quot;  class=&quot;text-blue-700&quot; &gt;My blue title&lt;/h1&gt;
</code></pre>
<p>and displayed as</p>
<h1 id="my-blue-title"  class="text-blue-700" >My blue title</h1>
<h2 id="refactoring">Refactoring</h2>
<p>I then decided to rewrite the contents of this website in Markdown using my new tool.</p>
<p>This is the reason why you see all the <strong  class="btn btn-accent" >buttons</strong>
and <strong  class="bg-orange-200" >highlighted texts</strong></p>
{% endfunc %}
